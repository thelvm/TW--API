/*
 * Generated by gdbus-codegen-glibmm 2.42.0. DO NOT EDIT.
 *
 * The license of this code is the same as for the source it was derived from.
 */

#include "touchless_gdbus_proxy.h"

#include <utility>

void com::thelvm::touchlessProxy::handle_signal(const Glib::ustring&/* sender_name */,
    const Glib::ustring& signal_name,
    const Glib::VariantContainerBase& parameters)
{
    static_cast<void>(signal_name); // maybe unused
    static_cast<void>(parameters); // maybe unused

    if (signal_name == "gesture_detected") {
        if (parameters.get_n_children() != 1) return;
        Glib::Variant<Glib::ustring> base_gesture;
        parameters.get_child(base_gesture, 0);
        Glib::ustring p_gesture;
        p_gesture = base_gesture.get();

        gesture_detected_signal.emit((p_gesture));
    }
}

void com::thelvm::touchlessProxy::handle_properties_changed(
    const Gio::DBus::Proxy::MapChangedProperties &changed_properties,
    const std::vector<Glib::ustring> &/* invalidated_properties */)
{
    static_cast<void>(changed_properties); // maybe unused

    // Only check changed_properties since value will already be cached. Glib can be setup to get
    // values of invalidated properties in which case property will be in changed_properties when
    // value is actually received. See Gio::DBus::ProxyFlags::PROXY_FLAGS_GET_INVALIDATED_PROPERTIES .

}

com::thelvm::touchlessProxy::touchlessProxy(const Glib::RefPtr<Gio::DBus::Proxy> &proxy) : m_proxy(proxy)
{
    m_proxy->signal_signal().connect(sigc::mem_fun(this, &touchlessProxy::handle_signal));
    m_proxy->signal_properties_changed().
        connect(sigc::mem_fun(this, &touchlessProxy::handle_properties_changed));
}

void com::thelvm::touchlessProxy::createForBus(
    Gio::DBus::BusType busType,
    Gio::DBus::ProxyFlags proxyFlags,
    const std::string &name,
    const std::string &objectPath,
    const Gio::SlotAsyncReady &slot,
    const Glib::RefPtr<Gio::Cancellable> &cancellable)
{
    Gio::DBus::Proxy::create_for_bus(busType,
        name,
        objectPath,
        "com.thelvm.touchless",
        slot,
        cancellable,
        Glib::RefPtr<Gio::DBus::InterfaceInfo>(),
        proxyFlags);
}

Glib::RefPtr<com::thelvm::touchlessProxy> com::thelvm::touchlessProxy::createForBusFinish(const Glib::RefPtr<Gio::AsyncResult> &result)
{
    Glib::RefPtr<Gio::DBus::Proxy> proxy =
        Gio::DBus::Proxy::create_for_bus_finish(result);
    com::thelvm::touchlessProxy *p =
        new com::thelvm::touchlessProxy(proxy);
    return Glib::RefPtr<com::thelvm::touchlessProxy>(p);
}

Glib::RefPtr<com::thelvm::touchlessProxy> com::thelvm::touchlessProxy::createForBus_sync(
    Gio::DBus::BusType busType,
    Gio::DBus::ProxyFlags proxyFlags,
    const std::string &name,
    const std::string &objectPath,
    const Glib::RefPtr<Gio::Cancellable> &cancellable)
{
    Glib::RefPtr<Gio::DBus::Proxy> proxy =
        Gio::DBus::Proxy::create_for_bus_sync(busType,
            name,
            objectPath,
            "com.thelvm.touchless",
            cancellable,
            Glib::RefPtr<Gio::DBus::InterfaceInfo>(),
            proxyFlags);
    com::thelvm::touchlessProxy *p =
        new com::thelvm::touchlessProxy(proxy);
    return Glib::RefPtr<com::thelvm::touchlessProxy>(p);
}
